# -*- coding: utf-8 -*-
"""Stat_Desc_TOUT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xgdLUSeTcziqt9kktcuc6KpKF8FERVGo

# Import
"""

!pip install pyproj
!pip install pycraf
!pip install swifter
!pip install geopandas
!pip install topojson
!pip install pandas fiona shapely pyproj rtree
!pip install contextily
!pip install geopandas
!pip install pygeos
!pip install topojson
! pip install requests py7zr geopandas openpyxl tqdm s3fs PyYAML xlrd! 
! pip install git+https://github.com/inseefrlab/cartogether

from google.colab import drive
drive.mount('/content/drive')

import geopandas as gpd
import scipy.stats
from tqdm import tqdm
import pandas as pd
import numpy as np
import sklearn as sk
from sklearn.linear_model import LinearRegression
from numpy import mean
import glob
import os
from datetime import datetime
import math
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
pd.set_option('display.max_columns', None)

data = pd.read_csv("/content/drive/Shareddrives/BDC Meilleur Taux Grp 4/base de données/Final.csv", )

"""# Distribution du prix_m2_actualise pour maison et appartement dans chaque métropole"""

def distribution_target_type_and_metropoles(data):
  for met in data.LIBEPCI.unique():
    g = sns.displot(data = data[data.LIBEPCI == met], x="prix_m2_actualise", hue="type_local", kde=True).set(title='Distribution of prix_m2_actualise for flats and houses, {}'.format(met))

distribution_target_type_and_metropoles(data)

data.groupby('LIBEPCI')["prix_m2_actualise"].max()

"""# Correlation heatmap générale"""

# Compute the correlation matrix
corr = data.corr()

# Generate a mask for the upper triangle
mask = np.triu(np.ones_like(corr, dtype=bool))

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(11, 9))

# Generate a custom diverging colormap
cmap = sns.diverging_palette(230, 100, as_cmap=True)

# Draw the heatmap with the mask and correct aspect ratio
sns.heatmap(corr, mask=mask, cmap=cmap, vmax=.3, center=0,
            square=True, linewidths=.5, cbar_kws={"shrink": .5})

"""# Heatmap dont distinct par ville"""

liste=['prix_m2_actualise',
       'nom_commune', 'LIBEPCI', 'code_departement', 'latitude', 'longitude',
       'type_local',
       'surface_reelle_bati', 'nombre_pieces_principales', 'surface_terrain',
       'prix_m2_zone',
       'trimestre_vente',
       'moyenne', 'moyenne_brevet',
       'Banques', 'Bureaux_de_Poste', 'Commerces', 'Ecoles', 'Collèges_Lycées', 'Medecins', 'Gares', 'Cinema', 'Bibliotheques', 'Espaces_remarquables_et_patrimoine', 
       'Taux_pauvreté_seuil_60', 'Q1', 'Mediane', 'Q3', 'Ecart_inter_Q_rapporte_a_la_mediane',
       'D1', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'D8', 'D9',
       'Rapport_interdécile_D9/D1', 'S80/S20', 'Gini',
       'Part_revenus_activite', 'Part_salaire', 'Part_revenus_chomage', 'Part_revenus_non_salariées', 'Part_retraites', 'Part_revenus_patrimoine',
       'Part_prestations_sociales', 'Part_prestations_familiales', 'Part_minima_sociaux', 'Part_prestations_logement', 'Part_impôts']

data2 = data[liste]

def plot_heatmap(data, variable_ref, local=None, color= sns.diverging_palette(29 , 29, center = 'light', sep = 1, n = 40)):
  plt.figure(figsize=(8, 12))
  if local:
    heatmap = sns.heatmap(data[data.LIBEPCI == local].corr()[[variable_ref]].sort_values(by=variable_ref, ascending=False), vmin=-1, vmax=1, annot=True, cmap=color)
    heatmap.set_title("Features Correlating with {}, {}".format(variable_ref, local), fontdict={'fontsize':18}, pad=16);  
  else:
    heatmap = sns.heatmap(data.corr()[[variable_ref]].sort_values(by=variable_ref, ascending=False), vmin=-1, vmax=1, annot=True, cmap=color)
    heatmap.set_title("Features Correlating with {}".format(variable_ref), fontdict={'fontsize':18}, pad=16);

for local in data.LIBEPCI.unique():
  plot_heatmap(data2, 'prix_m2_actualise', local)

plot_heatmap(data2, 'prix_m2_actualise')

"""# Maison vs Appartement par métropole"""

def plot_flats_houses_shares(data):
  
  # set the figure size
  plt.figure(figsize=(20, 8))

  # from raw value to percentage
  total = data.groupby('LIBEPCI')['type_local'].count().reset_index()
  type_local = data[data.type_local=='Appartement'].groupby('LIBEPCI')['type_local'].count().reset_index()
  type_local['type_local'] = [i / j * 100 for i,j in zip(type_local['type_local'], total['type_local'])]
  total['type_local'] = [i / j * 100 for i,j in zip(total['type_local'], total['type_local'])]

  # bar chart 1 -> top bars (group of 'smoker=No')
  bar1 = sns.barplot(x="LIBEPCI",  y="type_local", data=total, color='orange')

  # bar chart 2 -> bottom bars (group of 'smoker=Yes')
  bar2 = sns.barplot(x="LIBEPCI", y="type_local", data=type_local, color='grey')

  # add legend
  top_bar = mpatches.Patch(color='orange', label='Maison')
  bottom_bar = mpatches.Patch(color='grey', label='Appartement')
  plt.legend(handles=[top_bar, bottom_bar])

  # show the graph
  plt.xticks(rotation=40)
  plt.show()

plot_flats_houses_shares(data)

def box_flats_houses(data):  
  fig = plt.figure(figsize=(20,8))

  plt.subplot(1, 2, 1)
  sns.boxplot(data=data, x="type_local", y="surface_reelle_bati", palette = ['grey', 'orange'])

  plt.subplot(1, 2, 2)
  sns.boxplot(data=data, x="type_local", y="nombre_pieces_principales", palette = ['grey', 'orange'])

  plt.show()

box_flats_houses(data)

def box_flats_houses_surface(data):
  fig = plt.figure(figsize=(20,8))

  plt.subplot(1, 2, 1)
  sns.boxenplot(data=data, x="type_local", y="surface_reelle_bati", palette = ['grey', 'orange'])

  plt.subplot(1, 2, 2)
  sns.boxenplot(data=data, x="type_local", y="nombre_pieces_principales", palette = ['grey', 'orange'])

  plt.show()

box_flats_houses_surface(data)

palet_10 = sns.dark_palette("orange", 10)
palet_cmap = sns.dark_palette("orange", as_cmap=True)

def box_flats_houses_metropoles(data):
  fig = plt.figure(figsize=(10,15))

  palet = sns.dark_palette("orange", 10)

  plt.subplot(2, 1, 1)
  ax=sns.boxplot(data=data, x="type_local", y="surface_reelle_bati",hue="LIBEPCI", palette = palet_10)
  sns.move_legend(ax, "upper left", bbox_to_anchor=(1, 1))

  plt.subplot(2, 1, 2)
  ax2=sns.boxplot(data=data, x="type_local", y="nombre_pieces_principales",hue="LIBEPCI", palette = palet_10)
  sns.move_legend(ax2, "upper left", bbox_to_anchor=(1, 1))
  plt.show()

box_flats_houses_metropoles(data)

def box_flats_houses_metropoles_2(data):
  fig = plt.figure(figsize=(10,15))

  plt.subplot(2, 1, 1)
  ax=sns.boxenplot(data=data, x="type_local", y="surface_reelle_bati",hue="LIBEPCI", palette = palet_10)
  sns.move_legend(ax, "upper left", bbox_to_anchor=(1, 1))

  plt.subplot(2, 1, 2)
  ax2=sns.boxenplot(data=data, x="type_local", y="nombre_pieces_principales",hue="LIBEPCI", palette = palet_10)
  sns.move_legend(ax2, "upper left", bbox_to_anchor=(1, 1))
  plt.show()

box_flats_houses_metropoles_2(data)

"""# Préparation cartes"""

# convertir en geopandas pour la suite
def convert_gpd(df):
  return gpd.GeoDataFrame(
    df, geometry = gpd.points_from_xy(df.longitude, df.latitude))

data = convert_gpd(data)

iris_value = pd.read_csv('/content/drive/Shareddrives/BDC Meilleur Taux Grp 4/base de données/IRIS_donnees.csv', delimiter = ';')
iris_shape = gpd.read_file('/content/drive/Shareddrives/BDC Meilleur Taux Grp 4/base de données/IRIS_contours.shp')

iris_shape.drop_duplicates(subset=['DCOMIRIS'], keep = 'first', inplace = True)
iris_value.drop_duplicates(subset=['IRIS'], keep = 'first', inplace = True)

communes_shape = gpd.read_file('/content/drive/Shareddrives/BDC Meilleur Taux Grp 4/base de données/communes-20220101.shp')

def iris_prep(iris_value, iris_shape, value_on, shape_on):

  iris_shape.drop_duplicates(subset=['DCOMIRIS'], keep = 'first', inplace = True)
  iris_value.drop_duplicates(subset=['IRIS'], keep = 'first', inplace = True)
  iris_value[value_on] = iris_value[value_on].astype(str).str.rjust(9, '0')

  # merge iris_shape et iris_value pour avoir les polygones dans la même table que les variables de chaque IRIS
  iris = iris_shape.merge(iris_value, how = 'left', right_on = value_on, left_on = shape_on)
  iris.drop_duplicates(subset=['DCOMIRIS'], keep = 'first', inplace = True)

  return iris

iris = iris_prep(iris_value, iris_shape, 'IRIS', 'DCOMIRIS')

iris['iris_geometry'] = iris.geometry
data_2 = gpd.sjoin(data, iris, how='left', op='within')
data_2 = data_2.drop(columns = ['iris_geometry'])

data_2 = data_2.set_crs(4171)

data_2['nom_commune'] = data_2['nom_commune'].str.upper()
data_2.loc[data_2.NOM_COM.str.startswith('PARIS ').fillna(False), 'NOM_COM'] = 'Paris'
data_2.loc[data_2.NOM_COM.str.startswith('MARSEILLE ').fillna(False), 'NOM_COM'] = 'Marseille'
data_2.loc[data_2.NOM_COM.str.startswith('LYON ').fillna(False), 'NOM_COM'] = 'Lyon'
data_2['NOM_COM'] = data_2['NOM_COM'].str.upper()


iris.loc[iris.NOM_COM.str.startswith('PARIS ').fillna(False), 'NOM_COM'] = 'Paris'
iris.loc[iris.NOM_COM.str.startswith('MARSEILLE ').fillna(False), 'NOM_COM'] = 'Marseille'
iris.loc[iris.NOM_COM.str.startswith('LYON ').fillna(False), 'NOM_COM'] = 'Lyon'
iris['NOM_COM'] = iris['NOM_COM'].str.upper()

communes_shape.nom = communes_shape.nom.str.upper()

# !!!!!!!!!!!!!!!! CHOOSE THE PALETTE FOR THE COLORS !!!!!!!!!!!!!!!!

# cmap = sns.dark_palette("orange", reverse=True, as_cmap=True)
cmap = plt.get_cmap("jet")

"""# IRIS seul avec choix de la variable de fond"""

def plot_var_iris(area, var, size):
  figure = iris[iris.NOM_COM == area].plot(column = var,
                                                  figsize = size,
                                                  legend = True,
                                                  cmap=cmap,
                                                  legend_kwds={'label': "prix m2 moyen des biens de l'IRIS"})
  figure.set_axis_off()

# plot_var_iris('LYON', 'DISP_TP6019')
plot_var_iris('PARIS', 'DISP_RD19', (20,10))

"""# Tous les biens seul, choix de la ville"""

def bien(area, size):
  '''
  Tous les biens d'une commune sur le fond de la commune. Couleur correspond au prix_m2
  '''
  # cmap = sns.dark_palette("orange", reverse=True, as_cmap=True)

  data_2.to_crs(communes_shape.crs)
  base = communes_shape[communes_shape.nom == area].plot(figsize = size, alpha = 0.1)
  figure = data_2[data_2['NOM_COM'] == area].plot(ax = base,
                                                      column = 'prix_m2_actualise',
                                                      figsize = size,
                                                      alpha = 0.2,
                                                      legend = True,
                                                      cmap=cmap,
                                                      legend_kwds={'label': "prix m2 des biens"})
  figure.set_axis_off()

bien('NICE', (20,10))

"""# Tous les biens par IRIS
*   choix de la métropole
*   fond IRIS = revenu médian
*   point bien est prix_m2_actualise
*   Élément de liste




"""

def iris_bien(area, size):

  '''
  Tous les biens d'une commune sur le fond de l'IRIS.
  Couleurs correspondend au revenus médian (IRIS) et au prix_m2 de chaque bien
  '''

  data_2.to_crs(iris.crs)
  # liste_iris = data_2[data_2['nom_commune'] == area].DCOMIRIS_left
  base = iris.loc[iris.NOM_COM == area].plot(column = 'DISP_MED19',
                                                                                figsize = size,
                                                                                cmap=cmap,
                                                                                legend = True,
                                                                                legend_kwds={'label': "revenu médian dans l'IRIS"})
  figure = data_2[data_2.NOM_COM == area].plot(ax = base,
                                                  column = 'prix_m2_actualise',
                                                  figsize = size,
                                                  legend = True, 
                                                  cmap=cmap,
                                                  legend_kwds={'label': "prix m2 des biens"})
  figure.set_axis_off()

iris_bien('PARIS', (20,10))

"""# IRIS + bien moyen
*   choix de la métropole
*   fond IRIS = choix de la variable
*   point bien = prix_m2_actualise
"""

iris_value.columns

def iris_bien_moyen(area, metrique, var_iris, name_var_iris, size):

  '''
  Bien moyen de chaque IRIS sur le fond de l'IRIS.
  Couleurs correspondend au revenus médian (IRIS) et au prix_m2 moyen des biens de l'IRIS
  '''


  inter = data_2.groupby(['DCOMIRIS_right'])[[metrique]].mean()
  inter.reset_index(inplace=True)
  iris_moyenne = inter.merge(iris, how = 'right', left_on = 'DCOMIRIS_right', right_on = 'DCOMIRIS')
  iris_moyenne = gpd.GeoDataFrame(iris_moyenne[[metrique, 'DCOMIRIS', 'NOM_COM']], geometry = iris_moyenne['geometry'])
  iris_moyenne['center'] = iris_moyenne.centroid
  base = iris.loc[iris.NOM_COM == area].plot(column = var_iris,
                                                                                figsize = size,
                                                                                legend = True,
                                                                                cmap=cmap, 
                                                                                legend_kwds={'label': "{}. dans l'IRIS".format(name_var_iris)})
  iris_moyenne = iris_moyenne.set_geometry('center').to_crs(iris.crs)
  figure = iris_moyenne[iris_moyenne.NOM_COM == area].plot(ax = base,
                                                  column = metrique,
                                                  figsize = size,
                                                  legend = True,
                                                  cmap=cmap,
                                                  legend_kwds={'label': "{}. dans l'IRIS".format(metrique)}
                                                  )

  figure.set_axis_off()

iris_bien_moyen('PARIS', metrique = 'prix_m2_actualise', var_iris = 'DISP_EQ19', name_var_iris = 'écart inter-quartile rapporté à la moyenne des revenus', size = (20,10))

iris_bien_moyen('NICE', metrique = 'prix_m2_actualise', var_iris = 'DISP_EQ19', name_var_iris = 'écart inter-quartile rapporté à la moyenne des revenus', size = (20,10))

"""# Préparation Equipements"""

equipements = pd.read_csv('/content/drive/Shareddrives/BDC Meilleur Taux Grp 4/base de données/bpe21_ensemble_xy.csv', sep = ';')

equipements = gpd.GeoDataFrame(
    equipements, geometry = gpd.points_from_xy(equipements.LAMBERT_X, equipements.LAMBERT_Y))

liste_equi = ['A203', 'A206', 'B101', 'C101',  'C201', 'D201', 'E107', 'F303', 'F307',  'F313']
equipements = equipements[equipements['TYPEQU'].isin(liste_equi)]
equipements = equipements.replace({'A203': 'Banque', 'A206': 'Poste', 'B101': 'Alimentation', 'C101': 'Ecoles',  'C201': 'College-Lycee',
                         'D201': 'Medecin', 'E107': 'Gare',  'F303': 'Cinema', 'F307': 'Bibliotheque',  'F313': 'Patrimoine'})

equipements_crs = equipements.set_crs('2154')

equipements_crs = equipements_crs.to_crs(iris.crs)

equipements_crs.columns

"""# Equipements par ville, fond ville"""

def equi(area, num_com, size):
  
  base = communes_shape[communes_shape.nom == area].plot(figsize = size, alpha = 0.1)
  
  figure = equipements_crs[equipements_crs['DEPCOM'] == num_com].plot(ax = base,
                                                              column = 'TYPEQU',
                                                              figsize = size,
                                                              legend = True, 
                                                              cmap=plt.get_cmap("jet")
                                                              # legend_kwds={'label': "Type d'équipement"}
                                                              )
  figure.set_axis_off()

equi('PARIS', '75118', (20,10))

"""# Equipements par IRIS, fond IRIS"""

def equi_iris(num_iris, size):

  base = iris[iris.DCOMIRIS == num_iris].plot(figsize = size, alpha = 0.1)


  figure = equipements_crs[equipements_crs['DCIRIS'] == num_iris].plot(ax = base,
                                                              column = 'TYPEQU',
                                                              figsize = size,
                                                              legend = True, 
                                                              cmap=plt.get_cmap("jet")
                                                              # legend_kwds={'label': "Type d'équipement"}
                                                              )
  figure.set_axis_off()

equi_iris('751187022', (20,10))

"""# Corrélation entre deux variables par IRIS

*   choix de la métropole
*   choix des deux variables pours lesquelles étudier la corrélation
*   valeur par defaut des colonnes : prix_m2_actualise et prix_m2_zone -> permet d'étudier la corrélation spatiale du prix au m2
*   choix de la méthode de correlation (kendall, spearman ou pearson)


"""

def corr_iris(method, iris, col_1, col_2):
  points_iris = data_2[(data_2['IRIS_x']==iris[0]) & (data_2['IRIS_y']==iris[1])]
  x, y = [points_iris[col_1],points_iris[col_2]]
  if (len(x)>2) & (np.min(x)!= np.max(x)) & (np.min(y)!= np.max(y)):
    if method == 'pearson':
      corr = scipy.stats.pearsonr(x, y)[0]
    elif method == 'spearman':
      corr = scipy.stats.spearmanr(x, y)[0]
    elif method == 'kendall':
      corr = scipy.stats.kendalltau(x, y)[0]
  else:
    corr = np.nan
  return(corr)

def plot_corr_spatiale(area, col_1 = 'prix_m2_actualise', col_2 = 'prix_m2_zone', method = 'spearman', size=(20,10)):
  base_area = iris.loc[iris.NOM_COM == area].reset_index(drop=True)
  column_corr = []
  for index_iris in tqdm(base_area.index):
    data_iris = base_area.iloc[index_iris]
    column_corr.append(corr_iris(method, [data_iris['IRIS_x'],data_iris['IRIS_y']], col_1, col_2))
  base_area['corr_spatiale'] = column_corr

  base = communes_shape[communes_shape.nom == area].plot(figsize = size, alpha = 0.1)

  figure = base_area.plot(ax = base,
                                                  column = 'corr_spatiale',
                                                  figsize = size,
                                                  legend = True, 
                                                  cmap=cmap,
                                                  legend_kwds={'label': "Corrélation spatiale dans l'IRIS ({}) dans la ville de {}".format(method, area)})

  figure.set_axis_off()

plot_corr_spatiale('PARIS',method = 'spearman')
plot_corr_spatiale('LYON',method = 'spearman')
plot_corr_spatiale('LILLE',method = 'spearman')
plot_corr_spatiale('MARSEILLE',method = 'spearman')
plot_corr_spatiale('MONTPELLIER',method = 'spearman')
plot_corr_spatiale('TOULOUSE',method = 'spearman')
plot_corr_spatiale('BORDEAUX',method = 'spearman')
plot_corr_spatiale('RENNES',method = 'spearman')
plot_corr_spatiale('NANTES',method = 'spearman')
plot_corr_spatiale('NICE',method = 'spearman')